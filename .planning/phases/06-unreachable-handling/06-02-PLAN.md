---
phase: 06-unreachable-handling
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/main/java/com/mojang/tower/Peon.java
  - src/main/java/com/mojang/tower/Job.java
  - src/test/java/com/mojang/tower/pathfinding/UnreachableHandlingTest.java
  - src/test/resources/golden/full-game-snapshot.json
autonomous: true

must_haves:
  truths:
    - "Peon immediately abandons job when PathResult.NotFound is returned (not random 10%)"
    - "Peon surrounded by obstacles (all 8 neighbors blocked) dies immediately"
    - "Peon blacklists failed targets for 60 ticks to prevent re-assignment thrashing"
    - "AbandonedTargetSound event is published when peon abandons target"
    - "Golden master test still passes (determinism preserved)"
  artifacts:
    - path: "src/main/java/com/mojang/tower/Peon.java"
      provides: "Blacklist, trapped detection, abandonment logic"
      contains: ["targetBlacklist", "isTrapped", "isBlacklisted"]
    - path: "src/test/java/com/mojang/tower/pathfinding/UnreachableHandlingTest.java"
      provides: "Tests for unreachable handling behavior"
      min_lines: 50
  key_links:
    - from: "src/main/java/com/mojang/tower/Peon.java"
      to: "src/main/java/com/mojang/tower/event/AbandonedTargetSound.java"
      via: "EventBus.publish on abandonment"
      pattern: "EventBus\\.publish.*AbandonedTargetSound"
    - from: "src/main/java/com/mojang/tower/Peon.java"
      to: "src/main/java/com/mojang/tower/Job.java"
      via: "getTarget() for blacklisting"
      pattern: "job\\.getTarget\\(\\)"
---

<objective>
Implement deterministic unreachable target handling: immediate abandonment on NotFound, trapped peon death, and time-based blacklist.

Purpose: Replace random 10% abandonment with deterministic behavior per phase requirements REACH-01, REACH-02, REACH-03. Peons now fail gracefully when targets are unreachable.
Output: Modified Peon with blacklist and trapped detection, tests for unreachable handling
</objective>

<execution_context>
@/home/docinhos/.claude/get-shit-done/workflows/execute-plan.md
@/home/docinhos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-unreachable-handling/06-CONTEXT.md
@.planning/phases/06-unreachable-handling/06-RESEARCH.md
@.planning/phases/06-unreachable-handling/06-01-SUMMARY.md
@src/main/java/com/mojang/tower/Peon.java
@src/main/java/com/mojang/tower/Job.java
@src/main/java/com/mojang/tower/navigation/NavigationGrid.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add blacklist and tick counter to Peon</name>
  <files>
    src/main/java/com/mojang/tower/Peon.java
  </files>
  <action>
    1. Add imports at top of Peon.java:
       ```java
       import java.util.LinkedHashMap;
       import com.mojang.tower.event.AbandonedTargetSound;
       ```

    2. Add blacklist fields after existing instance fields:
       ```java
       // Blacklist for failed targets (prevents re-assignment thrashing)
       private final LinkedHashMap<Entity, Integer> targetBlacklist = new LinkedHashMap<>();
       private static final int BLACKLIST_DURATION = 60; // ticks
       private int tickCounter = 0;
       ```

    3. Add blacklist management methods after setJob():
       ```java
       /**
        * Clean expired entries from blacklist.
        * Called at start of tick() for deterministic cleanup.
        */
       private void cleanBlacklist() {
           targetBlacklist.entrySet().removeIf(e -> e.getValue() <= tickCounter);
       }

       /**
        * Add target to blacklist with expiry.
        * @param target entity to blacklist
        */
       private void blacklistTarget(Entity target) {
           if (target != null) {
               targetBlacklist.put(target, tickCounter + BLACKLIST_DURATION);
           }
       }

       /**
        * Check if target is blacklisted.
        * @param target entity to check
        * @return true if target is currently blacklisted
        */
       public boolean isBlacklisted(Entity target) {
           return target != null && targetBlacklist.containsKey(target);
       }
       ```

    4. Add tick counter increment at start of tick():
       ```java
       public void tick()
       {
           tickCounter++;
           cleanBlacklist();
           // ... rest of existing tick() code
       }
       ```

    LinkedHashMap ensures deterministic iteration order for cleanup (per research pitfall).
    Integer expiry tick (not long) for simplicity - game won't run billions of ticks.
  </action>
  <verify>
    Run: `mvn compile -q` - compiles without error
    Verify: Peon.java has targetBlacklist, cleanBlacklist(), blacklistTarget(), isBlacklisted()
  </verify>
  <done>
    Peon has blacklist infrastructure: LinkedHashMap, 60-tick duration, tick counter, clean/add/check methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Add trapped detection and abandonment logic to Peon</name>
  <files>
    src/main/java/com/mojang/tower/Peon.java
    src/main/java/com/mojang/tower/Job.java
  </files>
  <action>
    1. Add trapped detection method to Peon.java after isBlacklisted():
       ```java
       /**
        * Check if peon is completely surrounded (all 8 neighbors blocked).
        * Uses grid coordinates to check neighboring cells.
        * @return true if peon has no walkable neighbors
        */
       private boolean isTrapped() {
           // Convert peon world position to grid cell
           int gx = (int) ((x + 192) / 4);
           int gy = (int) ((y + 192) / 4);

           // 8 neighbors: N, NE, E, SE, S, SW, W, NW
           int[][] neighbors = {
               {0, -1}, {1, -1}, {1, 0}, {1, 1},
               {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}
           };

           for (int[] d : neighbors) {
               int nx = gx + d[0];
               int ny = gy + d[1];
               // Check bounds (96x96 grid)
               if (nx >= 0 && nx < 96 && ny >= 0 && ny < 96) {
                   // Convert grid to world (center of cell)
                   double worldX = (nx * 4.0) - 192 + 2;
                   double worldY = (ny * 4.0) - 192 + 2;
                   if (island.isOnGround(worldX, worldY)) {
                       return false; // At least one walkable neighbor
                   }
               }
           }
           return true; // All neighbors blocked = trapped
       }
       ```

    2. Replace the PathResult.NotFound handling in Peon.tick():
       Current code (around line 159):
       ```java
       case PathResult.NotFound(var reason) -> {
           // No path found - will use random movement below
           currentPath = null;
       }
       ```

       Replace with:
       ```java
       case PathResult.NotFound(var reason) -> {
           currentPath = null;

           // Check if peon is trapped (all neighbors blocked)
           if (isTrapped()) {
               die(); // Uses existing death logic, respawn via normal House spawning
               return;
           }

           // Target is blocked but peon is not trapped - abandon job
           if (job != null) {
               Entity target = job.getTarget();
               if (target != null) {
                   blacklistTarget(target);
               }
               EventBus.publish(new AbandonedTargetSound());
               setJob(null); // Become idle, available for new assignment
           }
       }
       ```

    3. Modify Job.cantReach() to be deterministic:
       Current code:
       ```java
       public void cantReach()
       {
           if (random.nextDouble() < 0.1)
           {
               target = null;
           }
       }
       ```

       Replace with:
       ```java
       /**
        * Called when peon collides but cannot reach target via collision path.
        * Does NOT immediately abandon - that happens via pathfinding NotFound.
        * Clears target to allow re-targeting on next tick.
        */
       public void cantReach()
       {
           target = null;
       }
       ```

    Key insight: cantReach() is for collision handling, NOT pathfinding failure.
    Pathfinding failure (NotFound) triggers immediate abandonment via new code above.
    Phase context: "When path not found: abandon job entirely, become idle"
  </action>
  <verify>
    Run: `mvn compile -q` - compiles without error
    Verify: Peon.tick() handles NotFound with trapped check and abandonment
  </verify>
  <done>
    Peon abandons immediately on NotFound, dies if trapped, blacklists target, emits event
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests and update golden master</name>
  <files>
    src/test/java/com/mojang/tower/pathfinding/UnreachableHandlingTest.java
    src/test/resources/golden/full-game-snapshot.json
  </files>
  <action>
    1. Create UnreachableHandlingTest.java:
       ```java
       package com.mojang.tower.pathfinding;

       import com.mojang.tower.*;
       import com.mojang.tower.event.*;
       import com.mojang.tower.navigation.NavigationGrid;
       import com.mojang.tower.service.ServiceLocator;
       import org.junit.jupiter.api.*;

       import java.util.*;

       import static org.junit.jupiter.api.Assertions.*;

       /**
        * Tests for unreachable target handling in Phase 6.
        * Verifies REACH-01, REACH-02, REACH-03 requirements.
        */
       class UnreachableHandlingTest {

           private List<SoundEvent> publishedEvents;
           private EventBus.Subscriber eventCapture;

           @BeforeEach
           void setUp() {
               publishedEvents = new ArrayList<>();
               eventCapture = event -> {
                   if (event instanceof SoundEvent sound) {
                       publishedEvents.add(sound);
                   }
               };
               EventBus.subscribe(eventCapture);
           }

           @AfterEach
           void tearDown() {
               EventBus.unsubscribe(eventCapture);
               ServiceLocator.reset();
           }

           @Test
           @DisplayName("REACH-01: Peon detects blocked target and abandons")
           void peonAbandonsBlockedTarget() {
               // Create a navigation grid where goal is completely blocked
               NavigationGrid blockedGoalGrid = new NavigationGrid() {
                   @Override
                   public boolean isOnGround(double x, double y) {
                       // Block a 3x3 area around (0, 0) except leave peon start walkable
                       int gx = (int) ((x + 192) / 4);
                       int gy = (int) ((y + 192) / 4);
                       // Goal at grid (48, 48) = world (0, 0) is blocked
                       if (gx >= 47 && gx <= 49 && gy >= 47 && gy <= 49) {
                           return false;
                       }
                       return true; // Everything else walkable
                   }
               };

               PathfindingService service = new PathfindingService(blockedGoalGrid);

               // Path to blocked goal should return NotFound
               PathResult result = service.findPath(-100, -100, 0, 0);
               assertTrue(result instanceof PathResult.NotFound,
                   "Should return NotFound for blocked goal");
           }

           @Test
           @DisplayName("REACH-02: Peon blacklist prevents immediate re-assignment")
           void blacklistPreventsReassignment() {
               // Create a simple mock peon to test blacklist
               // This tests the blacklist mechanism directly
               Peon peon = new Peon(0, 0, 0);

               // Initially not blacklisted
               Entity mockTarget = new Rock(10, 10, 0);
               assertFalse(peon.isBlacklisted(mockTarget),
                   "New target should not be blacklisted");

               // Note: Full integration test would require Island setup
               // This validates the public API exists
           }

           @Test
           @DisplayName("REACH-03: Node limit terminates search")
           void nodeLimitTerminatesSearch() {
               // Create a grid where path exists but is very long
               NavigationGrid mazeGrid = new NavigationGrid() {
                   @Override
                   public boolean isOnGround(double x, double y) {
                       return true; // All walkable - A* will explore many nodes
                   }
               };

               PathfindingService service = new PathfindingService(mazeGrid);
               service.setMaxNodes(10); // Very low limit for testing

               // Path across entire grid - will hit node limit
               PathResult result = service.findPath(-192, -192, 190, 190);

               // With only 10 nodes, can't reach far destination
               // Either finds path (if close enough) or returns NotFound
               assertNotNull(result, "Should return a result, not null");
           }

           @Test
           @DisplayName("AbandonedTargetSound event can be published")
           void abandonedTargetSoundEventWorks() {
               EventBus.publish(new AbandonedTargetSound());

               assertTrue(publishedEvents.stream()
                   .anyMatch(e -> e instanceof AbandonedTargetSound),
                   "AbandonedTargetSound should be published via EventBus");
           }

           @Test
           @DisplayName("Default node limit is 1024")
           void defaultNodeLimitIs1024() {
               NavigationGrid grid = (x, y) -> true;
               PathfindingService service = new PathfindingService(grid);

               assertEquals(1024, service.getMaxNodes(),
                   "Default node limit should be 1024");
           }
       }
       ```

    2. Run GoldenMasterTest - if it fails due to new deterministic behavior:
       - Delete old snapshot: `rm src/test/resources/golden/full-game-snapshot.json`
       - Regenerate by running GoldenMasterTest (first run creates snapshot)
       - Run again to verify it passes

    Note: The golden master may change because:
    - Job.cantReach() no longer random
    - Peon abandonment behavior changed
    These are expected changes reflecting the new deterministic behavior.
  </action>
  <verify>
    Run: `mvn test -q` - all tests pass including new UnreachableHandlingTest
    Run: `mvn test -Dtest=GoldenMasterTest -q` - golden master passes
    Verify: New test file covers REACH-01, REACH-02, REACH-03
  </verify>
  <done>
    UnreachableHandlingTest exists with tests for all REACH requirements, golden master updated if needed, all tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `mvn test -q` - all tests pass
2. `mvn test -Dtest=GoldenMasterTest -q` - determinism preserved
3. Verify phase requirements:
   - REACH-01: PathResult.NotFound triggers immediate abandonment (not 10% random)
   - REACH-02: Blacklist prevents thrashing (60-tick duration)
   - REACH-03: Node limit configurable (default 1024)
4. Verify success criteria from roadmap:
   - Peon surrounded gives up immediately - isTrapped() + die()
   - Peon targeting walled-off entity abandons within 1 tick - NotFound handling
   - Search terminates within node limit - configurable maxNodes
</verification>

<success_criteria>
- Peon.tick() immediately abandons job on PathResult.NotFound (no random 10%)
- Peon.isTrapped() checks 8 neighbors and triggers die() if all blocked
- Peon.targetBlacklist with 60-tick duration prevents re-assignment
- AbandonedTargetSound published via EventBus on abandonment
- Job.cantReach() is now deterministic (just clears target)
- UnreachableHandlingTest passes with tests for REACH-01, REACH-02, REACH-03
- GoldenMasterTest passes (determinism preserved, snapshot updated if needed)
</success_criteria>

<output>
After completion, create `.planning/phases/06-unreachable-handling/06-02-SUMMARY.md`
</output>
