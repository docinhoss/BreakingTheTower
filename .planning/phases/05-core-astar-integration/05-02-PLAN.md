---
phase: 05-core-astar-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/main/java/com/mojang/tower/pathfinding/PathfindingService.java
  - src/main/java/com/mojang/tower/service/ServiceLocator.java
  - src/main/java/com/mojang/tower/TowerComponent.java
  - src/main/java/com/mojang/tower/Peon.java
  - src/test/java/com/mojang/tower/pathfinding/PathfindingServiceTest.java
autonomous: true

must_haves:
  truths:
    - "Peon walks around a rock to reach a target on the other side"
    - "Peon moves diagonally when that is the shortest path"
    - "Peon falls back to random movement when path cannot be found"
    - "PathfindingService is accessible via ServiceLocator.pathfinding()"
    - "Golden master test still passes (determinism preserved)"
    - "Pathfinding completes within tick budget (no frame drops with 20 peons)"
  artifacts:
    - path: "src/main/java/com/mojang/tower/pathfinding/PathfindingService.java"
      provides: "Public API for pathfinding with world coordinate conversion"
      contains: "public final class PathfindingService"
      exports: ["findPath"]
    - path: "src/main/java/com/mojang/tower/service/ServiceLocator.java"
      provides: "PathfindingService registration"
      contains: "pathfindingService"
    - path: "src/main/java/com/mojang/tower/Peon.java"
      provides: "Path following logic"
      contains: "currentPath"
  key_links:
    - from: "PathfindingService.java"
      to: "AStarPathfinder"
      via: "delegates to internal pathfinder"
      pattern: "AStarPathfinder"
    - from: "ServiceLocator.java"
      to: "PathfindingService"
      via: "provide/pathfinding methods"
      pattern: "PathfindingService"
    - from: "Peon.java"
      to: "ServiceLocator.pathfinding()"
      via: "requests paths when job has target"
      pattern: "ServiceLocator\\.pathfinding\\(\\)"
    - from: "TowerComponent.java"
      to: "ServiceLocator.provide(PathfindingService)"
      via: "initialization at startup"
      pattern: "provide.*PathfindingService"
    - from: "Peon.java"
      to: "job.xTarget/yTarget"
      via: "invalidates path when target moves"
      pattern: "pathTargetX|pathTargetY"
---

<objective>
Integrate pathfinding with the game systems so peons use computed paths.

Purpose: Wire the A* algorithm into the game. This plan creates the public PathfindingService API, registers it with ServiceLocator, and modifies Peon to follow computed paths instead of moving directly toward targets.
Output: Peons navigate around obstacles using A* pathfinding.
</objective>

<execution_context>
@/home/docinhos/.claude/get-shit-done/workflows/execute-plan.md
@/home/docinhos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-core-astar-integration/05-RESEARCH.md
@.planning/phases/05-core-astar-integration/05-01-SUMMARY.md

# Files to modify
@src/main/java/com/mojang/tower/service/ServiceLocator.java
@src/main/java/com/mojang/tower/TowerComponent.java
@src/main/java/com/mojang/tower/Peon.java

# Existing patterns
@src/main/java/com/mojang/tower/navigation/NavigationGrid.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PathfindingService and register with ServiceLocator</name>
  <files>
    src/main/java/com/mojang/tower/pathfinding/PathfindingService.java
    src/main/java/com/mojang/tower/service/ServiceLocator.java
    src/main/java/com/mojang/tower/TowerComponent.java
  </files>
  <action>
**PathfindingService.java** - Public facade for pathfinding:

```java
public final class PathfindingService {
    private final AStarPathfinder pathfinder;

    public PathfindingService(NavigationGrid grid) {
        this.pathfinder = new AStarPathfinder(grid);
    }

    /**
     * Find a path from world coordinates to target world coordinates.
     * Converts between continuous world space and discrete grid cells.
     *
     * @return PathResult.Found with waypoints (in grid cells), or PathResult.NotFound
     */
    public PathResult findPath(double fromX, double fromY, double toX, double toY) {
        GridCell start = worldToGrid(fromX, fromY);
        GridCell goal = worldToGrid(toX, toY);
        return pathfinder.findPath(start, goal);
    }

    /**
     * Convert grid cell to world coordinates (center of cell).
     */
    public static double gridToWorldX(GridCell cell) {
        return (cell.x() * 4.0) - 192 + 2;
    }

    public static double gridToWorldY(GridCell cell) {
        return (cell.y() * 4.0) - 192 + 2;
    }

    private GridCell worldToGrid(double x, double y) {
        int gx = (int) ((x + 192) / 4);
        int gy = (int) ((y + 192) / 4);
        return new GridCell(
            Math.clamp(gx, 0, GridCell.GRID_SIZE - 1),
            Math.clamp(gy, 0, GridCell.GRID_SIZE - 1)
        );
    }
}
```

**ServiceLocator.java** - Add PathfindingService registration following existing pattern:

1. Add private static field: `private static PathfindingService pathfindingService;`

2. Add provide method:
```java
public static void provide(PathfindingService service) {
    pathfindingService = service;
}
```

3. Add accessor:
```java
public static PathfindingService pathfinding() {
    if (pathfindingService == null) {
        throw new IllegalStateException("PathfindingService not initialized.");
    }
    return pathfindingService;
}
```

4. Update reset() to include: `pathfindingService = null;`

**TowerComponent.java** - Initialize PathfindingService at startup:

Find where MovementSystem is created and its NavigationGrid is set (in the init() or constructor area). After that initialization, add:
```java
PathfindingService pathfindingService = new PathfindingService(island);
ServiceLocator.provide(pathfindingService);
```

Note: Island implements NavigationGrid, so pass `island` directly.
  </action>
  <verify>
Compile succeeds: `cd /home/docinhos/Documents/Java/BreakingTheTower && mvn compile -q`
  </verify>
  <done>PathfindingService exists and is registered with ServiceLocator at game startup</done>
</task>

<task type="auto">
  <name>Task 2: Modify Peon to follow computed paths</name>
  <files>
    src/main/java/com/mojang/tower/Peon.java
  </files>
  <action>
Modify Peon.java to use pathfinding when moving toward job targets.

**CRITICAL: Preserve exact wanderTime behavior from original code:**
- wanderTime blocks job target processing when > 0 (line 118: `if (wanderTime == 0 && job != null && job.hasTarget())`)
- wanderTime decrements every tick when > 0 (line 136: `if (wanderTime > 0) wanderTime--;`)
- wanderTime is set to random 3-32 when blocked (line 158: `wanderTime = random.nextInt(30) + 3;`)

**Add new fields (after line 21 `private int wanderTime = 0;`):**
```java
private List<GridCell> currentPath;
private int pathIndex;
private double pathTargetX, pathTargetY;  // Track what target the path was computed for
```

Add imports at top of file:
```java
import java.util.List;
import com.mojang.tower.pathfinding.GridCell;
import com.mojang.tower.pathfinding.PathResult;
import com.mojang.tower.pathfinding.PathfindingService;
```

**Replace lines 117-160 (the movement section) with:**

```java
double speed = 1;
if (wanderTime == 0 && job != null && job.hasTarget())
{
    // Invalidate path if job target has moved significantly (>= 1 grid cell = 4 world units)
    if (currentPath != null) {
        double targetDx = job.xTarget - pathTargetX;
        double targetDy = job.yTarget - pathTargetY;
        if (targetDx * targetDx + targetDy * targetDy >= 16.0) {
            currentPath = null;  // Target moved, recompute path
        }
    }

    // Check if already at target
    double xd = job.xTarget - x;
    double yd = job.yTarget - y;
    double rd = job.targetDistance + r;
    if (xd * xd + yd * yd < rd * rd)
    {
        job.arrived();
        currentPath = null;
        speed = 0;
    }
    else
    {
        // Need path to target
        if (currentPath == null) {
            PathResult result = ServiceLocator.pathfinding().findPath(x, y, job.xTarget, job.yTarget);
            switch (result) {
                case PathResult.Found(var path) -> {
                    currentPath = path;
                    pathIndex = 1; // Skip first cell (current position)
                    pathTargetX = job.xTarget;
                    pathTargetY = job.yTarget;
                }
                case PathResult.NotFound(var reason) -> {
                    // No path found - will use random movement below
                    currentPath = null;
                }
            }
        }

        // Follow path if we have one
        if (currentPath != null && pathIndex < currentPath.size()) {
            GridCell waypoint = currentPath.get(pathIndex);
            double wx = PathfindingService.gridToWorldX(waypoint);
            double wy = PathfindingService.gridToWorldY(waypoint);

            // Check if close enough to waypoint
            double wdx = wx - x;
            double wdy = wy - y;
            if (wdx * wdx + wdy * wdy < 4.0) {
                pathIndex++;
                if (pathIndex >= currentPath.size()) {
                    currentPath = null; // Path complete
                }
            } else {
                rot = Math.atan2(wdy, wdx);
            }
        } else if (currentPath == null) {
            // No path available - random direction (same as original else branch)
            rot += (random.nextDouble() - 0.5) * random.nextDouble() * 2;
        }
    }
}
else
{
    // Original else branch: wanderTime > 0 OR no job OR job has no target
    rot += (random.nextDouble() - 0.5) * random.nextDouble() * 2;
}

if (wanderTime > 0) wanderTime--;

speed += level * 0.1;

double targetX = x + Math.cos(rot) * 0.4 * speed;
double targetY = y + Math.sin(rot) * 0.4 * speed;
MovementResult result = ServiceLocator.movement().move(
    new MovementRequest(this, targetX, targetY)
);
switch (result) {
    case MovementResult.Moved(var newX, var newY) -> {
        // Position already updated by MovementSystem
    }
    case MovementResult.Blocked(var blocker) -> {
        // Path is now invalid - clear and try again next tick
        currentPath = null;
        if (job != null) {
            if (blocker != null) {
                job.collide(blocker);
            } else {
                job.cantReach();
            }
        }
        // Original behavior preserved exactly
        rot = random.nextDouble() * Math.PI * 2;
        wanderTime = random.nextInt(30) + 3;
    }
}
```

**Update setJob() method to clear path when job changes:**
Replace existing setJob() with:
```java
public void setJob(Job job)
{
    this.job = job;
    this.currentPath = null; // Clear path when job changes
    if (job != null) job.init(island, this);
}
```
  </action>
  <verify>
Compile and run golden master test: `cd /home/docinhos/Documents/Java/BreakingTheTower && mvn test -Dtest=GoldenMasterTest -q`

Verify wanderTime behavior preserved:
1. grep for "if (wanderTime == 0" in Peon.java - should find the condition
2. grep for "if (wanderTime > 0) wanderTime--" in Peon.java - should find decrement
3. grep for "wanderTime = random.nextInt(30) + 3" in Peon.java - should find blocked behavior
  </verify>
  <done>Peon uses computed paths to navigate; golden master test passes; wanderTime behavior identical to original</done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for PathfindingService</name>
  <files>
    src/test/java/com/mojang/tower/pathfinding/PathfindingServiceTest.java
  </files>
  <action>
Create integration tests for PathfindingService coordinate conversion and API.

**Test cases:**

1. `worldToGrid_originMapsToCenter()` - World (0,0) should map to grid center (~48, 48).

2. `worldToGrid_boundsClamp()` - World coordinates outside -192 to +192 should clamp to grid bounds.

3. `gridToWorld_roundTrip()` - Converting grid to world and back should return same grid cell.

4. `findPath_worldCoordinates_returnsGridPath()` - Path from world coords returns list of GridCells.

5. `findPath_acrossMap_succeeds()` - Path from one corner to opposite corner finds route.

6. `performance_20PeonsPerTick_completesWithinBudget()` - Compute 20 paths in under 16ms (60fps tick budget).

Create mock NavigationGrid that returns true for all isOnGround calls (fully walkable map).

```java
@Test
void worldToGrid_originMapsToCenter() {
    // World origin (0,0) is center of 384x384 world
    // Should map to approximately center of 96x96 grid
    // (0 + 192) / 4 = 48
    NavigationGrid allWalkable = createAllWalkableGrid();
    PathfindingService service = new PathfindingService(allWalkable);

    PathResult result = service.findPath(0, 0, 0, 0);

    assertInstanceOf(PathResult.Found.class, result);
    PathResult.Found found = (PathResult.Found) result;
    assertEquals(1, found.path().size());
    assertEquals(new GridCell(48, 48), found.path().get(0));
}

@Test
void findPath_acrossMap_succeeds() {
    NavigationGrid allWalkable = createAllWalkableGrid();
    PathfindingService service = new PathfindingService(allWalkable);

    // From bottom-left to top-right of world
    PathResult result = service.findPath(-180, -180, 180, 180);

    assertInstanceOf(PathResult.Found.class, result);
    PathResult.Found found = (PathResult.Found) result;
    assertTrue(found.path().size() > 1);
}

@Test
void performance_20PeonsPerTick_completesWithinBudget() {
    // PATH-04: Pathfinding completes within tick budget (no frame drops)
    // Tick budget at 60fps = 16.67ms, allow pathfinding up to ~8ms (half budget)
    NavigationGrid allWalkable = createAllWalkableGrid();
    PathfindingService service = new PathfindingService(allWalkable);

    // Worst case: 20 peons all computing long paths across map
    long startTime = System.nanoTime();
    for (int i = 0; i < 20; i++) {
        // Random positions across the map
        double fromX = -180 + (i * 18);
        double fromY = -180 + (i * 9);
        double toX = 180 - (i * 18);
        double toY = 180 - (i * 9);
        service.findPath(fromX, fromY, toX, toY);
    }
    long endTime = System.nanoTime();
    long elapsedMs = (endTime - startTime) / 1_000_000;

    // Must complete in under 8ms to leave headroom for other tick work
    assertTrue(elapsedMs < 8, "20 pathfinding calls took " + elapsedMs + "ms, exceeds 8ms budget");
}

private NavigationGrid createAllWalkableGrid() {
    return new NavigationGrid() {
        @Override
        public boolean isOnGround(double x, double y) {
            return true;
        }
        @Override
        public boolean isFree(double x, double y, double radius, Entity exclude) {
            throw new UnsupportedOperationException();
        }
        @Override
        public Entity getEntityAt(double x, double y, double radius, TargetFilter filter, Entity exclude) {
            throw new UnsupportedOperationException();
        }
    };
}
```
  </action>
  <verify>
Tests pass: `cd /home/docinhos/Documents/Java/BreakingTheTower && mvn test -Dtest=PathfindingServiceTest -q`
  </verify>
  <done>PathfindingService integration tests pass confirming coordinate conversion works and performance meets tick budget</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `mvn compile -q` succeeds
2. `mvn test -q` - all tests pass including GoldenMasterTest
3. Verify ServiceLocator has pathfinding() method
4. Verify Peon.java contains currentPath field and uses PathfindingService
5. Verify wanderTime behavior preserved:
   - `grep -n "if (wanderTime == 0" src/main/java/com/mojang/tower/Peon.java` shows the guard condition
   - `grep -n "if (wanderTime > 0) wanderTime--" src/main/java/com/mojang/tower/Peon.java` shows decrement
   - `grep -n "wanderTime = random.nextInt(30) + 3" src/main/java/com/mojang/tower/Peon.java` shows blocked behavior
6. Verify path invalidation on target move:
   - `grep -n "pathTargetX" src/main/java/com/mojang/tower/Peon.java` shows target tracking
7. Performance test passes (PATH-04: 20 peons within tick budget)
8. Manual verification (optional): Run game, click target behind rock, observe peon pathfinding around it
</verification>

<success_criteria>
- [ ] PathfindingService exists with findPath(double, double, double, double) method
- [ ] PathfindingService registered in ServiceLocator with provide/pathfinding methods
- [ ] TowerComponent initializes PathfindingService with Island at startup
- [ ] Peon uses PathfindingService to get paths when job has target
- [ ] Peon follows waypoints from path instead of direct movement
- [ ] Peon clears path and falls back to random movement when blocked
- [ ] Peon invalidates path when job target moves significantly (>= 4 world units)
- [ ] wanderTime behavior identical to original (guard at line 118, decrement at 136, set at 158)
- [ ] Golden master test still passes (determinism preserved)
- [ ] Performance test passes (20 pathfinding calls < 8ms)
- [ ] All pathfinding tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-core-astar-integration/05-02-SUMMARY.md`
</output>
