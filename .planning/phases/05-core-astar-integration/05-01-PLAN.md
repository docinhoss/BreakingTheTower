---
phase: 05-core-astar-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main/java/com/mojang/tower/pathfinding/GridCell.java
  - src/main/java/com/mojang/tower/pathfinding/PathNode.java
  - src/main/java/com/mojang/tower/pathfinding/PathResult.java
  - src/main/java/com/mojang/tower/pathfinding/AStarPathfinder.java
  - src/test/java/com/mojang/tower/pathfinding/AStarPathfinderTest.java
autonomous: true

must_haves:
  truths:
    - "A* algorithm finds shortest path between two walkable grid cells"
    - "A* algorithm returns NotFound when no path exists"
    - "A* algorithm produces identical paths on repeated runs (deterministic)"
    - "Diagonal movement costs more than cardinal movement (14 vs 10)"
  artifacts:
    - path: "src/main/java/com/mojang/tower/pathfinding/GridCell.java"
      provides: "Immutable grid coordinate type"
      contains: "public record GridCell"
    - path: "src/main/java/com/mojang/tower/pathfinding/PathNode.java"
      provides: "A* node with g, h, f scores and parent reference"
      contains: "class PathNode"
    - path: "src/main/java/com/mojang/tower/pathfinding/PathResult.java"
      provides: "Sealed result type for path queries"
      contains: "sealed interface PathResult"
    - path: "src/main/java/com/mojang/tower/pathfinding/AStarPathfinder.java"
      provides: "A* algorithm implementation"
      contains: "class AStarPathfinder"
    - path: "src/test/java/com/mojang/tower/pathfinding/AStarPathfinderTest.java"
      provides: "Unit tests for pathfinding"
      min_lines: 50
  key_links:
    - from: "AStarPathfinder.java"
      to: "NavigationGrid"
      via: "constructor injection"
      pattern: "AStarPathfinder\\(NavigationGrid"
    - from: "AStarPathfinder.java"
      to: "GridCell"
      via: "uses for coordinates"
      pattern: "GridCell"
    - from: "AStarPathfinder.java"
      to: "PathResult"
      via: "return type"
      pattern: "PathResult findPath"
---

<objective>
Implement the core A* pathfinding algorithm with deterministic behavior.

Purpose: Create the foundation for intelligent peon navigation. This plan builds the pure algorithm layer without integration - types, algorithm, and tests.
Output: Working A* pathfinder that finds optimal 8-directional paths through a NavigationGrid.
</objective>

<execution_context>
@/home/docinhos/.claude/get-shit-done/workflows/execute-plan.md
@/home/docinhos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-core-astar-integration/05-RESEARCH.md

# Existing interfaces this must integrate with
@src/main/java/com/mojang/tower/navigation/NavigationGrid.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pathfinding value types</name>
  <files>
    src/main/java/com/mojang/tower/pathfinding/GridCell.java
    src/main/java/com/mojang/tower/pathfinding/PathNode.java
    src/main/java/com/mojang/tower/pathfinding/PathResult.java
  </files>
  <action>
Create the `com.mojang.tower.pathfinding` package with three files:

**GridCell.java** - Immutable record for grid coordinates:
```java
public record GridCell(int x, int y) {
    public static final int GRID_SIZE = 96;

    public boolean isValid() {
        return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;
    }
}
```
The 96x96 grid maps to world coordinates -192 to +192 (4 world units per cell).

**PathNode.java** - Mutable A* node (package-private, not part of public API):
```java
final class PathNode {
    private final GridCell cell;
    private int g;        // Cost from start
    private final int h;  // Heuristic to goal (constant)
    private PathNode parent;
    private boolean closed;

    // Constructor and accessors as shown in RESEARCH.md
}
```
Must be mutable to allow g-score updates when better paths are found.

**PathResult.java** - Sealed result type following codebase pattern (see MovementResult):
```java
public sealed interface PathResult {
    record Found(List<GridCell> path) implements PathResult {}
    record NotFound(String reason) implements PathResult {}
}
```

Follow existing codebase conventions:
- Package statement matching directory structure
- Javadoc on public types
- Use Java 21 records and sealed interfaces
  </action>
  <verify>
Files compile: `cd /home/docinhos/Documents/Java/BreakingTheTower && mvn compile -q`
  </verify>
  <done>Three new files exist in pathfinding package, all compile without errors</done>
</task>

<task type="auto">
  <name>Task 2: Implement A* algorithm with deterministic tie-breaking</name>
  <files>
    src/main/java/com/mojang/tower/pathfinding/AStarPathfinder.java
  </files>
  <action>
Implement the A* algorithm following the verified pattern from RESEARCH.md.

**AStarPathfinder.java** key requirements:

1. **Constructor** takes NavigationGrid for walkability queries.

2. **Deterministic priority queue** using Comparator that breaks ties:
   - Primary: lowest f-score (g + h)
   - Secondary: highest g-score (prefer nodes closer to goal in search tree)
   - Tertiary: x coordinate, then y coordinate (final determinism)

3. **8-directional movement** with costs:
   - Cardinal (N, E, S, W): cost 10
   - Diagonal (NE, SE, SW, NW): cost 14 (approximates 10 * sqrt(2))

4. **Octile heuristic** for admissible 8-directional distance:
   ```java
   int dx = Math.abs(from.x() - to.x());
   int dy = Math.abs(from.y() - to.y());
   return D * (dx + dy) + (D2 - 2 * D) * Math.min(dx, dy);
   ```

5. **Walkability check** converts grid cell to world coordinates (center of cell):
   ```java
   double worldX = (cell.x() * 4.0) - 192 + 2;
   double worldY = (cell.y() * 4.0) - 192 + 2;
   return grid.isOnGround(worldX, worldY);
   ```

6. **LinkedHashMap for closed set** to ensure deterministic iteration order.

7. **MAX_NODES limit** (1000) to prevent unbounded search on large open areas.

8. **Early termination** cases:
   - Start not walkable: return NotFound
   - Goal not walkable: return NotFound
   - Start equals goal: return Found with single-element path

**CRITICAL for golden master compatibility:**
- Use LinkedHashMap (NOT HashMap) for allNodes map
- Use explicit Comparator with all tie-breaking levels
- Use integer costs (10/14) not floats
  </action>
  <verify>
File compiles: `cd /home/docinhos/Documents/Java/BreakingTheTower && mvn compile -q`
  </verify>
  <done>AStarPathfinder.java exists with findPath method that returns PathResult</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for A* pathfinding</name>
  <files>
    src/test/java/com/mojang/tower/pathfinding/AStarPathfinderTest.java
  </files>
  <action>
Create comprehensive unit tests for the A* pathfinder.

**Test setup:** Create a mock NavigationGrid that uses a boolean[][] to define walkable cells:
```java
private static NavigationGrid createGrid(boolean[][] walkable) {
    return new NavigationGrid() {
        @Override
        public boolean isOnGround(double x, double y) {
            int gx = (int) ((x + 192) / 4);
            int gy = (int) ((y + 192) / 4);
            if (gx < 0 || gx >= walkable.length) return false;
            if (gy < 0 || gy >= walkable[0].length) return false;
            return walkable[gx][gy];
        }
        // Other methods can throw UnsupportedOperationException
    };
}
```

**Test cases to include:**

1. `findPath_straightLine_returnsOptimalPath()` - Path from (0,0) to (5,0) on open grid should have 6 cells.

2. `findPath_aroundObstacle_findsRoute()` - Wall from (2,0) to (2,4), path from (0,2) to (4,2) should go around.

3. `findPath_diagonal_shortestPath()` - Path from (0,0) to (3,3) should use diagonals (4 cells, not 7).

4. `findPath_noPath_returnsNotFound()` - Target completely surrounded by unwalkable cells.

5. `findPath_startEqualsGoal_returnsSingleCell()` - Same start and goal returns path with one cell.

6. `findPath_startNotWalkable_returnsNotFound()` - Start position on unwalkable cell.

7. `findPath_deterministic_sameResultEveryTime()` - Run same pathfind 100 times, verify all paths identical.

8. `findPath_diagonalCostsMore_prefersCardinal()` - When straight path exists, should not take unnecessary diagonals.

Use JUnit 5 annotations (@Test, @BeforeEach). Use assertInstanceOf for pattern matching on PathResult.
  </action>
  <verify>
Tests pass: `cd /home/docinhos/Documents/Java/BreakingTheTower && mvn test -Dtest=AStarPathfinderTest -q`
  </verify>
  <done>All 8 test cases pass, confirming A* correctness and determinism</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `mvn compile -q` succeeds (no compilation errors)
2. `mvn test -Dtest=AStarPathfinderTest` - all tests pass
3. Verify determinism: grep for LinkedHashMap in AStarPathfinder.java
4. Verify integer costs: grep for "= 10" and "= 14" in AStarPathfinder.java
</verification>

<success_criteria>
- [ ] GridCell record exists with isValid() method and GRID_SIZE constant
- [ ] PathNode class exists with g, h, f accessors and update method
- [ ] PathResult sealed interface has Found and NotFound variants
- [ ] AStarPathfinder uses NavigationGrid.isOnGround() for walkability
- [ ] AStarPathfinder uses LinkedHashMap (not HashMap) for determinism
- [ ] AStarPathfinder uses integer costs 10/14 (not floats)
- [ ] All unit tests pass including determinism test
- [ ] mvn compile and mvn test both succeed
</success_criteria>

<output>
After completion, create `.planning/phases/05-core-astar-integration/05-01-SUMMARY.md`
</output>
