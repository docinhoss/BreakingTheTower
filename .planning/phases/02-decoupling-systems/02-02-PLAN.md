---
phase: 02-decoupling-systems
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/main/java/com/mojang/tower/state/GameState.java
  - src/main/java/com/mojang/tower/state/TitleState.java
  - src/main/java/com/mojang/tower/state/PlayingState.java
  - src/main/java/com/mojang/tower/state/WonState.java
  - src/main/java/com/mojang/tower/event/EffectEvent.java
  - src/main/java/com/mojang/tower/TowerComponent.java
  - src/main/java/com/mojang/tower/House.java
  - src/main/java/com/mojang/tower/Peon.java
autonomous: true

must_haves:
  truths:
    - "Game transitions between title, playing, and won states correctly"
    - "Title screen shows logo and 'click to start'"
    - "Playing state allows building placement and game progression"
    - "Won state shows win screen after tower destruction"
    - "Puff effects appear when buildings are sold"
    - "InfoPuff effects appear when peons gain experience"
    - "No direct Puff/InfoPuff creation remains in entity classes"
    - "Golden master tests still pass (behavior preserved)"
  artifacts:
    - path: "src/main/java/com/mojang/tower/state/GameState.java"
      provides: "Sealed interface for game state machine"
      contains: "sealed interface GameState permits TitleState, PlayingState, WonState"
    - path: "src/main/java/com/mojang/tower/state/TitleState.java"
      provides: "Title screen state implementation"
      exports: ["tick", "render", "handleClick"]
    - path: "src/main/java/com/mojang/tower/state/PlayingState.java"
      provides: "Active gameplay state implementation"
      exports: ["tick", "render", "handleClick"]
    - path: "src/main/java/com/mojang/tower/state/WonState.java"
      provides: "Win screen state implementation"
      exports: ["tick", "render", "handleClick"]
    - path: "src/main/java/com/mojang/tower/event/EffectEvent.java"
      provides: "Sealed interface for visual effect events"
      contains: "sealed interface EffectEvent permits PuffEffect, InfoPuffEffect"
  key_links:
    - from: "TowerComponent.java"
      to: "GameState"
      via: "currentState field and tick/render/handleClick delegation"
      pattern: "currentState\\.(tick|render|handleClick)"
    - from: "House.java, Peon.java"
      to: "EventBus"
      via: "EventBus.publish(new PuffEffect/InfoPuffEffect)"
      pattern: "EventBus\\.publish\\(new (Puff|InfoPuff)Effect"
---

<objective>
Implement State pattern for game states and decouple Puff/InfoPuff effect creation via events.

Purpose: Replace boolean flag state management with explicit State pattern. Complete the decoupling by moving effect creation from entities to event handlers. This satisfies PTRN-01 (State pattern) and PTRN-04 (visual effects via events).
Output: GameState sealed interface with three states, EffectEvent hierarchy, and TowerComponent refactored to use state objects.
</objective>

<execution_context>
@/home/docinhos/.claude/get-shit-done/workflows/execute-plan.md
@/home/docinhos/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-decoupling-systems/02-RESEARCH.md
@.planning/phases/02-decoupling-systems/02-01-SUMMARY.md

# Key source files
@src/main/java/com/mojang/tower/TowerComponent.java
@src/main/java/com/mojang/tower/House.java
@src/main/java/com/mojang/tower/Peon.java
@src/main/java/com/mojang/tower/Puff.java
@src/main/java/com/mojang/tower/InfoPuff.java
@src/main/java/com/mojang/tower/event/EventBus.java
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create State pattern infrastructure</name>
  <files>
    src/main/java/com/mojang/tower/state/GameState.java
    src/main/java/com/mojang/tower/state/TitleState.java
    src/main/java/com/mojang/tower/state/PlayingState.java
    src/main/java/com/mojang/tower/state/WonState.java
  </files>
  <action>
Create the state package with sealed GameState interface and implementations:

**state/GameState.java:**
```java
public sealed interface GameState permits TitleState, PlayingState, WonState {
    GameState tick();
    GameState handleClick(int x, int y, int width, int height);
    boolean shouldTickIsland();
    boolean shouldIncrementGameTime();
    double getRotationDelta();  // Return rotation speed adjustment

    // Entry/exit hooks with default no-op implementations
    default void onEnter() {}
    default void onExit() {}
}
```

**state/TitleState.java:**
- tick() returns this (no state change in tick)
- handleClick() returns new PlayingState() on any click
- shouldTickIsland() returns false
- shouldIncrementGameTime() returns false
- getRotationDelta() returns -0.002 (auto-rotate)

**state/PlayingState.java:**
- Constructor takes reference to win callback (Runnable or Consumer)
- tick() returns this normally
- handleClick() returns this (state changes happen externally via win())
- shouldTickIsland() returns true
- shouldIncrementGameTime() returns true
- getRotationDelta() returns 0 (controlled by mouse)
- Add win() method that returns new WonState()

**state/WonState.java:**
- Track wonTime counter
- tick() increments wonTime, returns this
- handleClick() returns new PlayingState() if wonTime >= 90 (3 seconds at 30 TPS)
- shouldTickIsland() returns true (island keeps ticking in won state)
- shouldIncrementGameTime() returns false
- getRotationDelta() returns -0.002 (auto-rotate like title)
- getWonTime() accessor for render condition

NOTE: States should NOT hold references to TowerComponent. They return new states, and TowerComponent manages the transition.
  </action>
  <verify>
    mvn compile -f /home/docinhos/Documents/Java/BreakingTheTower/pom.xml
  </verify>
  <done>
    - GameState.java exists as sealed interface
    - TitleState, PlayingState, WonState implement GameState
    - Each state implements tick(), handleClick(), shouldTickIsland(), shouldIncrementGameTime(), getRotationDelta()
    - WonState tracks wonTime and has getWonTime() accessor
    - Project compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor TowerComponent to use GameState</name>
  <files>
    src/main/java/com/mojang/tower/TowerComponent.java
  </files>
  <action>
Replace boolean state flags with GameState object:

**Remove these fields:**
- `private boolean titleScreen = true, won = false;`
- `private int wonTime;` (moved to WonState)

**Add new field:**
- `private GameState currentState = new TitleState();`

**Refactor tick() method:**
```java
private void tick() {
    // State-driven rotation
    xRotA += currentState.getRotationDelta();

    // Existing rotation damping
    xRot += xRotA;
    xRotA *= 0.7;

    // Mouse scroll rotation (only in playing state - check shouldTickIsland as proxy)
    if (currentState.shouldTickIsland() && currentState instanceof PlayingState) {
        if (scrolling) {
            double xd = xMouse - xScrollStart;
            xRotA -= xd / 10000.0;
        } else {
            if (xMouse >= 0 && yMouse < height * 2 - 20 * 2 && yMouse > 80) {
                if (xMouse < 80) xRotA += 0.02;
                if (xMouse > width * 2 - 80) xRotA -= 0.02;
            }
        }
    }

    island.rot = xRot;
    tickCount++;
    if (tickCount % TICKS_PER_SECOND == 0) {
        frames = 0;
    }

    // State-driven game time
    if (currentState.shouldIncrementGameTime()) {
        gameTime++;
    }

    // State-driven island tick
    if (currentState.shouldTickIsland()) {
        island.tick();
    }

    // State tick (may return new state)
    GameState nextState = currentState.tick();
    transitionTo(nextState);
}
```

**Add transitionTo() helper:**
```java
private void transitionTo(GameState nextState) {
    if (nextState != currentState) {
        currentState.onExit();
        currentState = nextState;
        currentState.onEnter();
    }
}
```

**Refactor mousePressed() click handling:**
Replace the titleScreen/won flag checks with:
```java
// After mute button check...
GameState nextState = currentState.handleClick(me.getX(), me.getY(), width, height);
transitionTo(nextState);
if (!(currentState instanceof PlayingState)) {
    return;  // Don't process building clicks in non-playing states
}
// ... rest of building placement/sell logic
```

**Refactor renderGame() method:**
Replace `if (titleScreen)` and `if (won)` with pattern matching:
```java
switch (currentState) {
    case TitleState() -> {
        // existing title screen rendering
    }
    case WonState wonState -> {
        // existing won screen rendering
        // Replace: if (wonTime >= TICKS_PER_SECOND * 3)
        // With: if (wonState.getWonTime() >= TICKS_PER_SECOND * 3)
    }
    case PlayingState() -> {
        // existing playing rendering (HUD, buildings, etc.)
    }
}
```

**Refactor win() method:**
```java
public void win() {
    winScore = 100000 * (TowerComponent.TICKS_PER_SECOND * 60 * 30) / (gameTime);
    transitionTo(new WonState());
}
```

Add imports for state classes.
  </action>
  <verify>
    cd /home/docinhos/Documents/Java/BreakingTheTower && mvn compile
  </verify>
  <done>
    - titleScreen and won boolean fields removed
    - currentState field added with GameState type
    - tick() delegates to currentState methods
    - mousePressed() uses handleClick() for state transitions
    - renderGame() uses switch expression on currentState
    - win() transitions to WonState
    - Project compiles
  </done>
</task>

<task type="auto">
  <name>Task 3: Create EffectEvent and wire Puff/InfoPuff via events</name>
  <files>
    src/main/java/com/mojang/tower/event/EffectEvent.java
    src/main/java/com/mojang/tower/House.java
    src/main/java/com/mojang/tower/Peon.java
    src/main/java/com/mojang/tower/TowerComponent.java
  </files>
  <action>
**event/EffectEvent.java:**
Create sealed interface with effect event records:
```java
public sealed interface EffectEvent permits PuffEffect, InfoPuffEffect {
}

public record PuffEffect(double x, double y) implements EffectEvent {}
public record InfoPuffEffect(double x, double y, int image) implements EffectEvent {}
```

**House.java (line 245):**
- Replace: `island.addEntity(new Puff(x, y));`
- With: `EventBus.publish(new PuffEffect(x, y));`
- Add import for EffectEvent records

**Peon.java (line 211):**
- Replace: `island.addEntity(new InfoPuff(x, y, 0));`
- With: `EventBus.publish(new InfoPuffEffect(x, y, 0));`
- Add import for EffectEvent records

**TowerComponent.java - Add effect handler:**
```java
private void handleEffectEvent(EffectEvent event) {
    switch (event) {
        case PuffEffect(var x, var y) -> island.addEntity(new Puff(x, y));
        case InfoPuffEffect(var x, var y, var img) -> island.addEntity(new InfoPuff(x, y, img));
    }
}
```

**TowerComponent.init() - Subscribe to EffectEvent:**
Add after the SoundEvent subscription:
```java
EventBus.subscribe(EffectEvent.class, this::handleEffectEvent);
```

Add imports for EffectEvent, PuffEffect, InfoPuffEffect, Puff, InfoPuff.
  </action>
  <verify>
    cd /home/docinhos/Documents/Java/BreakingTheTower && mvn test -Dtest=GoldenMasterTest -q
  </verify>
  <done>
    - EffectEvent.java exists with PuffEffect and InfoPuffEffect records
    - House.puff() publishes PuffEffect instead of direct Puff creation
    - Peon levelUp publishes InfoPuffEffect instead of direct InfoPuff creation
    - TowerComponent subscribes to EffectEvent and handles Puff/InfoPuff creation
    - No direct Puff/InfoPuff creation in House or Peon
    - Golden master test passes
  </done>
</task>

</tasks>

<verification>
1. `mvn compile` passes - all state and event classes compile
2. `mvn test -Dtest=GoldenMasterTest` passes - behavior preserved
3. Manual test state transitions:
   - Launch game: Title screen shows with logo
   - Click: Transitions to playing state, HUD visible
   - Win game (destroy tower): Transitions to won state
   - Wait 3 seconds, click: Returns to playing state
4. Manual test effects:
   - Sell a building: Puff effect appears
   - Peon gains experience: InfoPuff effect appears
5. Code verification:
   - `grep -r "titleScreen" src/main/java` returns no matches
   - `grep -r "new Puff\|new InfoPuff" src/main/java/com/mojang/tower/*.java | grep -v TowerComponent` returns no matches
</verification>

<success_criteria>
- GameState sealed interface with TitleState, PlayingState, WonState implementations
- TowerComponent uses GameState instead of boolean flags
- State transitions work correctly (title -> playing -> won -> playing)
- EffectEvent with PuffEffect and InfoPuffEffect records
- Puff/InfoPuff creation via events, not direct instantiation in entities
- Golden master test passes (CRITICAL)
- All Phase 2 requirements satisfied (PTRN-01 through PTRN-05)
</success_criteria>

<output>
After completion, create `.planning/phases/02-decoupling-systems/02-02-SUMMARY.md`
</output>
